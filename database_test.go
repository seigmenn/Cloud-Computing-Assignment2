package main

import (
	"assignment-2/Handler"
	"context"
	firebase "firebase.google.com/go"
	"fmt"
	"google.golang.org/api/option"
	"testing"
)

/*
Function that tests both POST and GET.
The function sends hardcoded data to the Firestore client where it makes a document for the data.
This document is then retrieved and the function tests if the data in the document retrieved matches
the data that was sent.
*/
func TestAddAndGetDocumentFirebase(t *testing.T) {
	// Initialize a Firebase app using a service account file
	ctx := context.Background()
	sa := option.WithCredentialsFile(Handler.SERVICEACCOUNT)
	app, err := firebase.NewApp(ctx, nil, sa)
	//Error handling for it
	if err != nil {
		t.Fatal("Error initializing Firebase: ", err.Error())
	}

	//Get the Firestore client, so we can interact with the database
	fsClient, err := app.Firestore(ctx)
	if err != nil {
		t.Fatal("Error creating Firebase Client: ", err.Error())
	}

	//Find the collection that the user will insert the document into
	webhookCollection := fsClient.Collection(Handler.COLLECTION)

	//Adds test data for a webhook in a document in the webhook collection
	key, _, err := webhookCollection.Add(ctx,
		map[string]interface{}{
			"webhook_id":  "databaseTestWebhook",
			"url":         "testWebhook:8080",
			"country":     "test",
			"invocations": 0,
			"calls":       0,
		})

	//Error handling for it
	if err != nil {
		// Error handling prints to the terminal and postman console
		t.Fatal("Error adding document: ", err.Error())

	}

	//Gets the document ID (autogenerated on Firebase) of the new document
	docID := key.ID

	//Retrieve the document using the ID
	doc, err := webhookCollection.Doc(docID).Get(ctx)
	if err != nil {
		t.Fatal("Error retrieving the document: ", err.Error())
	}

	//Converts the data in the document into map[string]interface{} / same way info was stored
	data := doc.Data()
	docData := make(map[string]interface{})
	for key, info := range data {
		docData[key] = info
	}

	correctData := map[string]interface{}{
		"webhook_id":  "databaseTestWebhook",
		"url":         "testWebhook:8080",
		"country":     "test",
		"invocations": 0,
		"calls":       0,
	}

	//Checks if the lengths of the two maps are the same and fails test if not
	if len(docData) != len(correctData) {
		t.Fatalf("Document data is not the same as the correct data. Got %v and "+
			"expected %v", docData, correctData)
	}

	//For-loop that iterates over the correctData map. Since there's both integers and strings
	//in the map, it uses fmt.Sprintf to change both values to strings then checking if they're the same
	//If they're not the same then fails and prints an error message
	for key, testValue := range correctData {
		retrievedValue := docData[key]
		if fmt.Sprintf("%v", retrievedValue) != fmt.Sprintf("%v", testValue) {
			t.Fatalf("Document data is not the same as the correct data. Got: %v,"+
				"expected: %v", docData, correctData)
		}
	}
}
